## 剑指 offer
1. [二维数组查找](./1.py)

2. [替换空格](./2.py)

3. [输入一个链表，按链表从尾到头的顺序返回一个ArrayList。](3.py)

4. [重建二叉树](4.py)
  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
  例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

5. [两个栈来实现一个队列](5.py)
  用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

6. [旋转数组的最小数字](6.py)

7. [斐波那契数列](7.py)

8. [青蛙跳台阶](7.py)

9. [输出整数二进制的个数](8.py)
  输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

10. [调整数组的顺序，使得奇数在前偶数再后](9.py)

11. 输入一个链表，输出该链表中倒数第k个结点。](10.py)

12. [链表的反转](11.py)

13. [合并两个排序的链表](12.py)

14. [树的子结构](13.py)

15. [二叉树的镜像](14.py)

16. [二叉树](15.py)

    - 插入

    - 查找

    - 遍历

17. [堆](16.py)
17. [含min函数的最小栈](17.py)
2. [栈的压入、弹出序列](18.py)
3. [二叉树的遍历](19.py)
    - 二叉树的深度

    - 深度优先遍历

    - 广度优先遍历

    - 直径

  

20. [二叉搜索的后序遍历](20.py)
  输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。
  假设输入的数组的任意两个数字都互不相同。

21.  [二叉树和为某一个值的路径](21.py)
      输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
      路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
      
22. [二叉搜索树与链表][22.py]
      输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
      
23. [字符串排列](23.py)
      输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,
      则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
      输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
      
24. [组合总和](24.py)

      给定一个**无重复元素**的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

      `candidates` 中的数字可以无限制重复被选取。

      **说明：**

      - 所有数字（包括 `target`）都是正整数。
      - 解集不能包含重复的组合。

      **示例 1:**

      ```
      输入: candidates = [2,3,6,7], target = 7,
      所求解集为:
      [
        [7],
        [2,2,3]
      ]
      
      ```

      **示例 2:**

      ```
      输入: candidates = [2,3,5], target = 8,
      所求解集为:
      [
        [2,2,2,2],
        [2,3,3],
        [3,5]
      ]
      ```
25. [数组中出现次数超过一半的数](25.py)
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。
由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
  
26. [最小的k个数](26.py)
快速排序的思想，每次将数组分成两个有序的数组，然后再递归，注意边界条件

27. [连续子数组的最大和](27.py)

28. [整数中1出现的次数](28.py)

29. [把数组排列成最小的数](29.py)

30. [第一个只出现依次的字符串](30.py)

31. [两个链表的第一个公共节点](31.py)
输入两个链表，找出它们的第一个公共结点。（
注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

32. [数字在排序数组中出现的次数。](32.py) 

33. [循环数组中的最小值](33.py)

34. [二叉树的深度](34.py)

35. [数组中只出现一次的数字](35.py)
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

36. [和为S的连续正整数](36.py)
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
37. [和为S的连续正整数,乘积最大](37.py)

38. [左旋字符串](38.py)

39. [k最近邻](39.py)
我们有一个整形数组a，大小为n，里面的数字是按照由小到大排序的，无重复。现在给一个查询数字x和召回数k，要求返回a中和x最接近的k个数字。


41. [数组中重复的数字](41.py)

42. [字符流中第一个不重复的字符](42.py)

43. [链表的入口节点](43.py)

44. [删除链表中的重复节点](44.py)
   在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

   思路：

   1.设置一个虚拟头结点，设置两个指针，pre指向虚拟头结点，cur指向头结点。

   ![img](https://pic1.zhimg.com/80/v2-448a6dd66aecf42d947820b649dfd990_1440w.jpg)

   2.判断下一个节点的值和cur的值是否相等，若相等cur后移，直到下个节点的值和cur的值不同

   ![img](https://pic1.zhimg.com/80/v2-247ec1ffc075c6d806bed5ab9352aea8_1440w.jpg)

   3.此时执行pre.next= cur.next。

   ![img](https://pic1.zhimg.com/80/v2-3c8ed7ab91d62b3dd78e907e78800d94_1440w.jpg)

   4.继续走直到结尾.

   ![img](https://pic3.zhimg.com/80/v2-1ac54a5fa5dd85d7ac4b72d5b17eb59a_1440w.jpg)

45. [二叉树的下一个节点](45.py)

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

**思路：**如下图所示，二叉树的中序遍历序列是{d,b,h,e,i,a,f,c,g}。

![img](https://pic1.zhimg.com/80/v2-c24fbfeb07d85f63cbbe8e084297d52c_1440w.jpg)

1、如果该节点有右子树，那么它的下一个节点就是它的右子树的最左侧子节点；

2、如果该节点没有右子树且是父节点的左子树，那么下一节点就是父节点；

3、如果该节点没有右子树且是父节点的右子树，比如i节点，那么我们往上找父节点，找到一个节点满足： 它是它的父节点的左子树的节点

46. [判断一颗二叉树是不是对称的](46.py)
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。（leetcode101题）

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```text
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

**思路**

递归的思想，首先判断头结点是否为空。然后将根节点的左右两个节点假设成两个独立的树，如果左右两个树都为空，返回True。然后看左子树的左结点和右子树的右结点、左子树的右结点和右子树的左结点是否相同，都相同返回True.

47. [二叉树的序列化](47.py)
请实现两个函数，分别用来序列化和反序列化二叉树

二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。

二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。

48. [二叉搜索树的第K个节点](48.py)
给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。

![img](https://pic1.zhimg.com/80/v2-0abd8e8252a99bb70edf0b0864bb0e64_1440w.png)


49. [数据流中的中位数](49.py)
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。
如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

50. [滑动窗口中的最大值](50.py)
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，
他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：
 {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}

51. [矩阵中的路径](51.py)

   请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

   [["a","b","c","e"],
   ["s","f","c","s"],
   ["a","d","e","e"]]

   但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

   来源：力扣（LeetCode）
   链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof
   著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

52. [机器人的运动范围](52.py)
   地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。
   但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

   **示例 1：**

   ```
   输入：m = 2, n = 3, k = 1
   输出：3
   ```

   **示例 1：**

   ```
   输入：m = 3, n = 1, k = 0
   输出：1
   ```

53. [剪绳子](53.py)

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**示例**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1


```

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```


54. [礼物的最大价值](54.py)

    在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

    **示例 1**

    ```text
    示例 1:
    
    输入: 
    [
      [1,3,1],
      [1,5,1],
      [4,2,1]
    ]
    输出: 12
    解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
    ```

    

    


